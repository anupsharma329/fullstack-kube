name: CI/CD Pipeline for EKS

on:
  push:
    branches: [ "main", "master" ]
  pull_request:
    branches: [ "main", "master", "docker" ]

permissions:
  contents: read
  pull-requests: read
  security-events: write

env:
  REGISTRY: docker.io
  FRONTEND_IMAGE: anupsharma329/frontend
  BACKEND_IMAGE: anupsharma329/backend
  SONAR_PROJECT_KEY: anupsharma329_fullstack-react-app
  EKS_CLUSTER_NAME: fullstack-cluster
  EKS_REGION: us-east-1
  NAMESPACE: fullstack-app

jobs:
  build-and-test:
    name: Build and Test (frontend + backend)
    runs-on: ubuntu-latest
    outputs:
      should-deploy: ${{ steps.check-branch.outputs.should-deploy }}
    strategy:
      matrix:
        project: [ frontend, backend ]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check if should deploy
        id: check-branch
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" || "${{ github.ref }}" == "refs/heads/master" ]]; then
            echo "should-deploy=true" >> $GITHUB_OUTPUT
          else
            echo "should-deploy=false" >> $GITHUB_OUTPUT
          fi

      - name: Use Node.js 18
        uses: actions/setup-node@v4
        with:
          node-version: 18
          cache: 'npm'
          cache-dependency-path: |
            ${{ matrix.project }}/package-lock.json

      - name: Install dependencies
        working-directory: ${{ matrix.project }}
        run: npm ci

      - name: Run tests with coverage
        working-directory: ${{ matrix.project }}
        run: |
          npm run test --if-present -- --watch=false --ci --coverage --passWithNoTests || true

      - name: Build (if present)
        working-directory: ${{ matrix.project }}
        run: npm run build --if-present

  sonar-analysis:
    name: SonarQube Analysis
    needs: [ build-and-test ]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Use Node.js 18
        uses: actions/setup-node@v4
        with:
          node-version: 18

      - name: SonarQube Scan
        uses: SonarSource/sonarqube-scan-action@v2
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        with:
          args: >-
            -Dsonar.organization=${{ secrets.SONAR_ORGANIZATION }}
            -Dsonar.projectKey=${{ env.SONAR_PROJECT_KEY }}
            -Dsonar.sources=frontend/src,backend
            -Dsonar.exclusions=**/node_modules/**,**/*.test.js,**/*.spec.js,frontend/build/**,backend/node_modules/**
            -Dsonar.sourceEncoding=UTF-8
            -Dsonar.javascript.lcov.reportPaths=frontend/coverage/lcov.info,backend/coverage/lcov.info
            -Dsonar.coverage.exclusions=**/node_modules/**,**/*.test.js,**/*.spec.js
            -Dsonar.ci.autoconfig.disabled=true
            ${{ github.event_name == 'pull_request' && format('-Dsonar.pullrequest.key={0} -Dsonar.pullrequest.branch={1} -Dsonar.pullrequest.base={2}', github.event.pull_request.number, github.event.pull_request.head.ref, github.event.pull_request.base.ref) || '' }}

  build-and-push-docker:
    name: Build and Push Docker Images
    needs: [ build-and-test, sonar-analysis ]
    if: needs.build-and-test.outputs.should-deploy == 'true'
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Get Semantic Version
        id: version
        uses: paulhatch/semantic-version@v5.3.0
        with:
          tag_prefix: ""
          major_pattern: "BREAKING CHANGE:"
          minor_pattern: "feat:"

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}

      - name: Build and push Frontend Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          push: true
          tags: |
            ${{ env.FRONTEND_IMAGE }}:v${{ steps.version.outputs.version }}
            ${{ env.FRONTEND_IMAGE }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64

      - name: Build and push Backend Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          tags: |
            ${{ env.BACKEND_IMAGE }}:v${{ steps.version.outputs.version }}
            ${{ env.BACKEND_IMAGE }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64

      - name: Output version for deployment
        run: |
          echo "version=${{ steps.version.outputs.version }}" >> $GITHUB_OUTPUT
          echo "ğŸ“¦ Images tagged with: v${{ steps.version.outputs.version }}"

  deploy-to-eks:
    name: ğŸš€ Deploy to AWS EKS
    needs: [ build-and-push-docker ]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.EKS_REGION }}

      - name: Update kubeconfig for EKS cluster
        run: |
          aws eks update-kubeconfig \
            --region ${{ env.EKS_REGION }} \
            --name ${{ env.EKS_CLUSTER_NAME }}

      - name: Deploy to EKS
        run: |
          echo "ğŸš€ Starting deployment to EKS cluster: ${{ env.EKS_CLUSTER_NAME }}"
          
          # Debug version
          echo "Version from build job: '${{ needs.build-and-push-docker.outputs.version }}'"
          
          # Create namespace if it doesn't exist
          kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
          
          # Force use of versioned tags (not latest)
          VERSION="${{ needs.build-and-push-docker.outputs.version }}"
          echo "Deploying version: $VERSION"
          
          # Deploy backend with specific version
          echo "ğŸ“¦ Deploying backend..."
          kubectl set image deployment/backend-deployment \
            backend=${{ env.BACKEND_IMAGE }}:v$VERSION \
            -n ${{ env.NAMESPACE }}
          
          # Deploy frontend with specific version
          echo "ğŸ“¦ Deploying frontend..."  
          kubectl set image deployment/frontend-deployment \
            frontend=${{ env.FRONTEND_IMAGE }}:v$VERSION \
            -n ${{ env.NAMESPACE }}
          
          # Wait for rollout
          echo "â³ Waiting for deployments..."
          kubectl rollout status deployment/backend-deployment -n ${{ env.NAMESPACE }} --timeout=600s
          kubectl rollout status deployment/frontend-deployment -n ${{ env.NAMESPACE }} --timeout=600s
          
          # Check pod status with timeout and debugging
          echo "ğŸ” Checking pod status..."
          timeout 180s bash -c '
            while true; do
              BACKEND_READY=$(kubectl get deployment backend-deployment -n ${{ env.NAMESPACE }} -o jsonpath="{.status.readyReplicas}" 2>/dev/null || echo "0")
              FRONTEND_READY=$(kubectl get deployment frontend-deployment -n ${{ env.NAMESPACE }} -o jsonpath="{.status.readyReplicas}" 2>/dev/null || echo "0")
              
              echo "Backend ready: $BACKEND_READY/2, Frontend ready: $FRONTEND_READY/2"
              
              if [[ "$BACKEND_READY" -eq 2 && "$FRONTEND_READY" -eq 2 ]]; then
                echo "âœ… All pods are ready!"
                break
              fi
              
              sleep 10
            done
          ' || echo "âš ï¸ Timeout reached, checking status..."
          
          # Final status
          echo "ğŸ” Final status:"
          kubectl get deployments -n ${{ env.NAMESPACE }}
          kubectl get pods -n ${{ env.NAMESPACE }} -o wide
          
          # Get ALB URL
          ALB_URL=$(kubectl get ingress app-ingress -n ${{ env.NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "Not available yet")
          echo "ğŸŒ Application URL: http://$ALB_URL"

  notify:
    name: Notify Status
    needs: [ build-and-test, sonar-analysis, build-and-push-docker, deploy-to-eks ]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Notify Success
        if: success()
        run: |
          echo "âœ… CI/CD Pipeline completed successfully!"
          echo "â˜¸ï¸  Application deployed to EKS: ${{ env.EKS_CLUSTER_NAME }}"
          echo "ğŸ“¦ Check EKS console for ALB URL"

      - name: Notify Failure
        if: failure()
        run: |
          echo "âŒ CI/CD Pipeline failed"
          echo "ğŸ” Check the workflow logs for details"